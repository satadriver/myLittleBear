
#include "PublicVar.h"

#ifdef HOOK_ORG_DLL_YYVIDEOSDK
#include "littlebeardll.h"

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 头文件
#include <Windows.h>
#include "Shlwapi.h"
#pragma comment( lib, "Shlwapi.lib")
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 宏定义
#define EXTERNC extern "C"
#define NAKED __declspec(naked)
#define EXPORT __declspec(dllexport)

#define ALCPP EXPORT NAKED
#define ALSTD EXTERNC EXPORT NAKED void __stdcall
#define ALCFAST EXTERNC EXPORT NAKED void __fastcall
#define ALCDECL EXTERNC NAKED void __cdecl
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#define HOOK_LEN 0xC
// 保存原始指令
BYTE Ori_Code[HOOK_LEN] = {0x00};
BYTE HookCode[HOOK_LEN] = { 0x48, 0xB8, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x50, 0xC3 };

void HookApi();
void UnHookApi();

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// AheadLib 命名空间
namespace AheadLib
{
	HMODULE m_hModule = NULL;		// 原始模块句柄
	DWORD m_dwReturn[9] = {0};		// 原始函数返回地址


	// 加载原始模块
	inline BOOL WINAPI Load()
	{
		TCHAR tzPath[MAX_PATH];
		TCHAR tzTemp[MAX_PATH * 2];

		lstrcpy(tzPath, TEXT("VideoSdkOrg"));
		m_hModule = LoadLibrary(tzPath);
		if (m_hModule == NULL)
		{
			wsprintf(tzTemp, TEXT("无法加载 %s，程序无法正常运行。"), tzPath);
			MessageBox(NULL, tzTemp, TEXT("AheadLib"), MB_ICONSTOP);
		}

		return (m_hModule != NULL);	
	}
		
	// 释放原始模块
	inline VOID WINAPI Free()
	{
		if (m_hModule)
		{
			FreeLibrary(m_hModule);
		}
	}

	// 获取原始函数地址
	FARPROC WINAPI GetAddress(PCSTR pszProcName)
	{
		FARPROC fpAddress;
		CHAR szProcName[64];
		TCHAR tzTemp[MAX_PATH];

		fpAddress = GetProcAddress(m_hModule, pszProcName);
		if (fpAddress == NULL)
		{
			if (HIWORD(pszProcName) == 0)
			{
				wsprintfA(szProcName, "%d", pszProcName);
				pszProcName = szProcName;
			}

			wsprintf(tzTemp, TEXT("无法找到函数 %hs，程序无法正常运行。"), pszProcName);
			MessageBox(NULL, tzTemp, TEXT("AheadLib"), MB_ICONSTOP);
			ExitProcess(-2);
		}

		return fpAddress;
	}
}
using namespace AheadLib;
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//先声明Hook的API -- 赋值改成你要Hook的API；注意参数、返回值类型
static HMODULE (WINAPI * kernel_BeHooked_Api)(LPCSTR lpFileName) = LoadLibraryA;

//定义自己的API，参数和返回类型与上面声明的保持一致 -- 原API将被转到这里执行
HMODULE WINAPI My_Hook_Api(LPCSTR lpFileName)
{
	///////////////////////////////////////////////////////////////////
	//  下面是原API执行前想要做的事
	///////////////////////////////////////////////////////////////////
	DWORD PatchAddr    = 0;              //改为实际要补丁的地址
	BYTE  oldData[2]   = {0x74,0x1f};    //改为实际的带补丁代码
	BYTE  patchData[2] = {0x74,0x00};    //改为补丁数据
	BYTE  bufRead[2]   = {0};            //改为实际要读取进程的字节数

	DWORD dwOldProtect;
	DWORD bytesReadWritten;
	///////////////////////////////////////////////////////////////////


	///////////////////////////////////////////////////////////////////
	//  执行原API
	///////////////////////////////////////////////////////////////////
	UnHookApi();
	//  请注意修改参数和返回值类型
	HMODULE hRet = kernel_BeHooked_Api(lpFileName); 
	HookApi();
	///////////////////////////////////////////////////////////////////

	///////////////////////////////////////////////////////////////////
	//  下面是原API执行后想要做的事
	///////////////////////////////////////////////////////////////////
	PatchAddr = (DWORD)hRet + 0x103C; //改为你要补丁的目标地址！
	HANDLE hProcess = GetCurrentProcess();

	VirtualProtect((LPVOID)PatchAddr, sizeof(DWORD), PAGE_READWRITE, &dwOldProtect);
	ReadProcessMemory(hProcess, (LPVOID)PatchAddr, (LPVOID)bufRead, 2, &bytesReadWritten);
	if (memcmp(bufRead, oldData, 2) == 0)
	{
		OutputDebugString(TEXT("[PYG] Found the target!"));
		WriteProcessMemory(hProcess, (LPVOID)PatchAddr, &patchData, 2, &bytesReadWritten);
		OutputDebugString(TEXT("[PYG] Patch successfully!"));
	}
	VirtualProtect((LPVOID)PatchAddr, sizeof(DWORD), dwOldProtect, &dwOldProtect);
	///////////////////////////////////////////////////////////////////

	//注意返回值类型
	return hRet;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void HookApi()
{
	DWORD dwOldProtect;
	//获取内存权限
	::VirtualProtect(kernel_BeHooked_Api, HOOK_LEN, PAGE_EXECUTE_READWRITE, &dwOldProtect);
	//保存原代码数据
	memcpy(Ori_Code, kernel_BeHooked_Api, HOOK_LEN);
	//填入自己函数的地址
	*(PDWORD)(HookCode+2) = (DWORD)&My_Hook_Api;
	 //写入进程内存
	memcpy(kernel_BeHooked_Api, HookCode, HOOK_LEN);
	//恢复内存权限
	::VirtualProtect(kernel_BeHooked_Api, HOOK_LEN, dwOldProtect, &dwOldProtect);
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void UnHookApi()
{
	DWORD dwOldProtect;
	::VirtualProtect(kernel_BeHooked_Api, HOOK_LEN, PAGE_EXECUTE_READWRITE, &dwOldProtect);
	memcpy(kernel_BeHooked_Api, Ori_Code, HOOK_LEN);
	::VirtualProtect(kernel_BeHooked_Api, HOOK_LEN, dwOldProtect, &dwOldProtect);
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 入口函数
BOOL WINAPI DllMain(HMODULE hModule, DWORD dwReason, PVOID pvReserved)
{
	//MessageBoxA(0,0,0,0);
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		DisableThreadLibraryCalls(hModule);

		if(Load())
		{
			TCHAR szAppName[MAX_PATH]  = TEXT("MyApp.exe");	//请改为相应的Dll宿主文件名
			TCHAR szFullPath[MAX_PATH] = {0};
			int nLength = 0;
			nLength = GetModuleFileName(NULL, szFullPath, MAX_PATH);
			PathStripPath(szFullPath);
			//if (StrCmpI(szAppName, szFullPath) == 0)
			{
				//OutputDebugString(TEXT("[PYG] Dll Loaded successfully!"));
				HookApi();
			}
		}
		else
		{
			return FALSE;
		}
	}
	else if (dwReason == DLL_PROCESS_DETACH)
	{
		Free();
	}

	return TRUE;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 导出函数
#pragma comment(linker, "/EXPORT:GetInstance=_AheadLib_GetInstance,@2")
#pragma comment(linker, "/EXPORT:InitVideoService=_AheadLib_InitVideoService,@3")
#pragma comment(linker, "/EXPORT:UnInitVideoService=_AheadLib_UnInitVideoService,@4")
#pragma comment(linker, "/EXPORT:VideoSdk_GetInstance=_AheadLib_VideoSdk_GetInstance,@5")
#pragma comment(linker, "/EXPORT:VideoSdk_InitVideoService=_AheadLib_VideoSdk_InitVideoService,@6")
#pragma comment(linker, "/EXPORT:VideoSdk_UnInitVideoService=_AheadLib_VideoSdk_UnInitVideoService,@7")
#pragma comment(linker, "/EXPORT:vpFreeInstance=_AheadLib_vpFreeInstance,@8")
#pragma comment(linker, "/EXPORT:vpGetInterface=_AheadLib_vpGetInterface,@9")
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#define VERSION_DEBUG_OUTPUT

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//导出函数
ALCPP public: class std::_Init_locks & __thiscall std::_Init_locks::operator=(class std::_Init_locks const &)
{
	GetAddress("??4_Init_locks@std@@QAEAAV01@ABV01@@Z");
	__asm JMP EAX;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 导出函数
ALCDECL AheadLib_GetInstance(void)
{
#ifdef VERSION_DEBUG_OUTPUT
	MessageBoxA(0,"AheadLib_GetInstance","AheadLib_GetInstance",0);
#endif

	GetAddress("GetInstance");
	__asm JMP EAX;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 导出函数
ALCDECL AheadLib_InitVideoService(void)
{
#ifdef VERSION_DEBUG_OUTPUT
	MessageBoxA(0,"AheadLib_InitVideoService","AheadLib_InitVideoService",0);
#endif
	GetAddress("InitVideoService");
	__asm JMP EAX;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 导出函数
ALCDECL AheadLib_UnInitVideoService(void)
{
#ifdef VERSION_DEBUG_OUTPUT
	MessageBoxA(0,"AheadLib_UnInitVideoService","AheadLib_UnInitVideoService",0);
#endif
	GetAddress("UnInitVideoService");
	__asm JMP EAX;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 导出函数
ALCDECL AheadLib_VideoSdk_GetInstance(void)
{
#ifdef VERSION_DEBUG_OUTPUT
	MessageBoxA(0,"AheadLib_VideoSdk_GetInstance","AheadLib_VideoSdk_GetInstance",0);
#endif
	GetAddress("VideoSdk_GetInstance");
	__asm JMP EAX;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 导出函数
ALCDECL AheadLib_VideoSdk_InitVideoService(void)
{
#ifdef VERSION_DEBUG_OUTPUT
	MessageBoxA(0,"AheadLib_VideoSdk_InitVideoService","AheadLib_VideoSdk_InitVideoService",0);
#endif
	GetAddress("VideoSdk_InitVideoService");
	__asm JMP EAX;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 导出函数
ALCDECL AheadLib_VideoSdk_UnInitVideoService(void)
{
#ifdef VERSION_DEBUG_OUTPUT
	MessageBoxA(0,"AheadLib_VideoSdk_UnInitVideoService","AheadLib_VideoSdk_UnInitVideoService",0);
#endif
	GetAddress("VideoSdk_UnInitVideoService");
	__asm JMP EAX;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 导出函数
ALCDECL AheadLib_vpFreeInstance(void)
{
#ifdef VERSION_DEBUG_OUTPUT
	MessageBoxA(0,"AheadLib_vpFreeInstance","AheadLib_vpFreeInstance",0);
#endif
	GetAddress("vpFreeInstance");
	__asm JMP EAX;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 导出函数
ALCDECL AheadLib_vpGetInterface(void)
{
#ifdef VERSION_DEBUG_OUTPUT
	MessageBoxA(0,"AheadLib_vpGetInterface","AheadLib_vpGetInterface",0);
#endif
	GetAddress("vpGetInterface");
	__asm JMP EAX;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#endif